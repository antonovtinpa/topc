Правим чат система, която трябва да отговаря на следните изисквания:
- Трябва да поддържа само текстови съобщения
- Трябва да предоставя опция за директни съобщения и групови такива (групите са до 100 души), като историята на съобщенията се пази завинаги
- Трябва да има следене на статуса на активност на потребителите
- Трябва да работи на различни платформи web/mobile
- Трабвя да поддържа 50М DAU
- Няма нужда от енкрипция на първо време
- Предоставя push notification-и

Можем да започнем сизайна на нашата систем поетапно, като разгледаме отделно всички компоненти, които са ни нужни.
1. Стандартен дистрибутиран Web Server (API Service) - Трябва да имаме отделни инстанции на уеб сървръра, които ще стоят зад Load Balancer, този компонент ще отговаря за аутентикация/ауторизация и други стандартни действия, като например едитване на user data. Няма нищо извън традиционното тук, клиента праща HTTP request-и, сървъра отговаря подобаващо.
2. Chat Service - Тази услуга ще е в центъра на нашата система, като за начало трябва да изясним как ще се случва комуникацията межу сървъра и клиента. Ако се опитаме да работим със стандартни HTTP заявки, бързо ще раберем, че докогато клиента изпращя съобщения към сървръра всичко би било наред, но в момента, в който от сървъра трябва да съобщи на друг клиент, че е получил съобщение всичко става по-сложно. В практиката има различни методи за да се справим с това:
	1. Polling - При този метод клиента периодично праща заявки към сървъра за да провери дали има нови съобщения (прилича малко на въпроса на малките деца "Стигнахме ли вече?"), най-често отговорът ще е "не, няма нови съобщения", а в момента, в който има бихме ги пратили. Това прави този подход неподходящ за нашите цели, безпредметно е хабенето на ресурси с цел отговорът в повечето да е "не".
	2. Long Polling - Този метод е просто разширение на предишният, с разликата, че щом клиента прати заявки връзката остава отворена докато не получи отговор с ново съобщение или докато не изтече предварително установен timeout. Ако получим отговор веднага пращаме нова заявка. Подобно на предишният метод този е неподходящ, като цяло stateless природата на HTTP сървърите е неподходяща. Това ни подсказва, че трябва да използваме друг network protocol.
	3. Web Socket - WS връзката е двупосочна и персистентна, тя се инициализира от клиента като в началото тя представлява HTTP заявка, но след поредица от предварително установени протоколи тя може да се превърне в WS връзка.
	Тук съответно пак ще ни трябва отделни дистрибутирани сървъри, които да се справят с големият трафик, който очакваме. 
3. Presence Service - Тази услуга подобно на предишната ще използва WS. Веднъж щом клиента установи WS връзка, ние запазваме статуса му като онлайн, в случай на logout запазваме статуса като офлайн. В случай обаче на disconnection трябва да имаме в предвид възможността за слаб интернет или друга ситуация, която моментно нарушава връзката и после я възтановява, тоест не можем веднага щом потребителя загуби връзка да сетваме статуса му като офлайн, вместо това използваме heartbeat механизъм, при който през определен интервал клиента изпраща евент, който доказва, че още използва връзката и чак след като сървъра не получи никаква индикация за онлайн присъстие след определено време тогава сетваме офлайн статус. При всяка смяна на статус трябва да предаваме данните на заинтересованите потребители, това може да случи чрез pub-sub механизъм, където приятели се subsrcibe-ват за определени канали или ако искаме по-щадящ подход можем да имплементираме някакво селективно фечване.
4. Service Discovery - Тази услуга ще се използва от Web Server-a в момента на аутентикация, тя ще има за задача да предостави най-подходящият chat/presence съръвър, на база геолокация и натоварване на отделните ни инстанции.
5. Third Party Services - Най-вероятно за момента това ще бъдe notification service-a
6. Storage - Трябват ни два вида съхранение
	1. Relational DB - Ще използваме релационна база за станадртните данни като user profile, настройки и предпочитания.
	2. Key-Value Store - Докато на теория можем да пазим и чат историята в релационна база данни, по-удачно би било да се възползваме от стратегиите на продукти като Facebook & Discord, които използват KV storage-и като HBase & Cassandra. Има няколко причини за това:
		1. KV Storage-ите се скалират хоризонтално много по-лесно
		2. KV Storage-ите ни предоставят low latency достъп до данните
		3. При голям обем от данни, какъвто очакваме, random access-a при релационните бази данни става много по-скъп от към време.
7. Data Models - Тази стъпка е изключително важна за да решим проблема си с факта, че всички съобщения трябва да бъдат сортируеми с цел да предоставяме подобаващо последните съобщения на потребителите. За директните съобщения ни трябва изпращач, получател, съдържание и timestamp за създаване, но самият timestamp не е достатъчен за сортиране на съобщенията понеже две съобщения могат да бъдат пратени в едно и също време, трябва ни Message ID, което да следва поредност, в релационна база данни, бихме използвали autoincrement, но в КV store нямаме такава опция, другият вариант е да използваме Snowflake ID Generator-а от преди няколко глави, но можем и да минем с по-прост подход. Имплементираме локален ID Generator, където за всеки отделен чат създаваме аутоинкрементирани ID-та. За груповите чатове, ни трябва още един параметър Group ID/ Channel ID, с който ще направим composite key.

Примерен flow на системата ни към този момент:
1. Потребител А праща заявка за аутентикация
2. Load Balancer препраща заявката към Web Server
3. Web Server-a установява аутентикация и комуникира с Service Discovery-то
4. Service Discovery връща походящ chat & presence server и клиента установява връзка
5. Потребител А изпраща съобщение към Потребител Б
6. Chat Server-a приема съобщението и използва ID Generator-a и препраща съобщението с ID-то и другите нужни данни към Message Queue
7. Message Queue-то има за задача да запази съобщението в KV Storage-a и да го препрати към Потребител Б
	1. Ако Потребител Б е на линия Message Queue-то препраща съобщението към Chat Server 2, който има установена връзка с Потребител Б, а той от своя страна комуникира новото съобщение към клиента
	2. Ако Потребител Б НЕ е на линия, съобщението се препраща към Push Notification Service, в момента, в който Потребител Б установи връзка послените съобщения му се пращат. Като бележка, на клиента се пази посленто Message ID, което е получено от потребителя, при установяване на връзка всички съобщеният с по-голямо ИД се синхронизират. 