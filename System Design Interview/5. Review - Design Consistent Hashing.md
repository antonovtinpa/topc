Преди да направим дизайн на consistent hashing първо разглеждаме защо е нужен и къде се използва. Разглеждаме хеширането като важен компонент при хоризонталното скалиране на база данни или така нареченият шардинг, връщаме се на първа глава за да обобщя какво представляваше процеса на шардинг - Имаме няколко ДБ сървъра или няколко бази, които споделят една и съща схема, но съдържат различни данни, като тези данни се разпределят между сървърите на база хеширащ алгоритърм, първо имаме ключ, който сами трябва да изберем, и който преминава през хешираща функция, която ни връща числена стойност, на тази числена стойност се прилага модулус от Н, където Н е броят на сървърите. Това е най-простият начин за шардинг -> формулата е serverIndex = hashingFn(key) % N. Проблемът на този подход е че в случай, че един от сървърите фейлне или решим да увеличим броят на сървърите ние трябва да rehash-нем голяма част от ключовете поради факта че след като Н се промени повечето hashingFn(key) % N резултати ще се различават от оригиналните.

Тук се намесва consistent hashing, това е подход, при който "изграждаме" hashing space, който се състои от всички възможни output-и от хеширащата функция. На база това хеширано пространство "изграждаме" hashing ring, който се получава, когато "съединим" началото и края на хешираното пространство. Следваща стъпка е да "заложим" нашите сървъри върху пръстена, като просто пуснем тяхното ИП или някакво ИД през хеширащата функция и ги поставим в съответният слот. След като имаме пръстена и сървърите върху него вече можем да инсертваме данни, това случва по следният начин - хешираме ключа и търсим слота му върху пръстена, след като го намерим започваме да обхождаме пръстена по посока часовниковата стрелка докато не намерим сървър, данните се записват в първият намерен съръвър. По този начин дори и да премахнем или добавим сървър ние средно трябва да рехешираме К/Н броя ключа като К е общият брой ключове а Н е общият брой слотове.

Има обаче два основни проблема с този подход на този етап.
1. Напълно възможно е един сървър да съдържа пъти в повече данни от друг поради начин, по който се дистрибутират ключовете
2. Също е напълно възможно един сървър да покрива в пъти по-голям интервал върху пръстена от други
Решението е да използваме virtual nodes, това са един вид "дистрибутори" на сървъра (реалният ноуд), те са разпределени върху пръстена, като те са много на брой 100, 150, 200 за всеки съръвър и са равномерно разпределени върху пръстена. Намирането на сървър пак се случва по посока на часовниковата стрелка просто когато срещнем витруален ноуд ние реферираме към сървъра. Правя аналогия с интегралите, в смисъла на броят ВНоудове, стига да имаме достатъчен брой малки правоъгълници под функцията, ние можем да намерим приблизителното лице.