Така имаме задача да направим дизайн за линк shortener. Първото нещо, което трябва да направим е да изясним изискванията за тази система, те са следните:
- Искаме УРЛ шортнер, който да приема дълъг урл и да ни предоставят къс такъв. Съответно, когато потребителя предостави наш къс УРЛ ние трябва да му предоставим оригиналният.
- Иска се от нас системата да поддържа генерирането на 100 милиона УРЛ всеки ден.
- Самият урл (или по-скоро хаш стойността, кяото ще разгледаме по-късно) трябва да е съставен от главни и малки английски букви и от цифри. Той трябва да е възможно най-къс.
- Back of the envelope estimates
	- Нека изясним колко заявки за записване в секунда трябва да поддържаме 100 милиона за един ден / 24 часа / 3600 секунди прави 1160 заявки за записване
	- Ако предположим, че съотношението четене:писане е 10:1, тогава трябва да поссържаме и 11 600 заявки за четене
	- Нека да подготвим и нужната памет ако предположим, че тази система ще работи 10 години. 100 мил. заявки на ден * 365 дни в годината * 10 години прави 365 милярда записвания за 10 години. Ако предположим, че размера консумиран за всеки УРЛ е 100 байта, то тогава ще ни трябва около 36 терабайта. **Бележка: В книгата се казва 365 терабайта, но мисля, че има грешка, защото авторът умножава 10 години два пъти.**
След като вече имаме основните параметри, с които ще работим е време за базовият дизай. Като за начало ще ни трябва някакво АПИ, което да предоставя достъп до услугата. Самото АПИ има нужда от един ПОСТ ендпойнт, който да генерира късият линк и един ГЕТ ендпойнт, който да върща на (редиректва към) потребителя оригиналният УРЛ.
В сърцето на услугата е скъсяването на УРЛ-а, за се превърне един дълъг линк в скъсен такъв трябва да използваме някаква хаш стойност, която да е уникална за всеки УРЛ, и която да се използва в късият линк: https://imagine-a-long-url.com -> https://short.com/hash. Колко дълъг трябва да е този хаш, за да изпълним условието за възможно най-къс такъв? Ами имаме 62 възможни символа 26 малки букви 26 главни букви и 10 цифри. Тоест трябва ни L, който отговаря на условието: $$62^L \geq 365 \ billion \ unique \ hashes$$ 
Тоест Л = 7, което е равно на приблизително 3.5 трилиона.
Имаме два основни подхода за хеширащата функция.
1. Хеширане + Справяне а колизии - При този подход бихме използвали стандарни хеширащи функции като MD5, SHA-1, CRC32. Резултатите от тези хеширащи фунции са с определена сължина, като най-къси резултати произвежда CRC, въпреки това те са по-дълги от 7. Можем например да взимаме само първите 7 символа от резултата, но това води до увеличена възможност за колизии. За да се справим с това, ние бихме използвали рекурсивна функция, която да хешира дългият линк, докато не получим резултат, който не съществува в базата ни, като условието е, че след всяко извикване не функцията прибавяме някакъв стриг, който да ни осигурни различен резултат.
2. Base62 конверсия - Base 62 сonversion стратегията се основава на преобразуването на определно ИД в base 62, подобно на base 16 за hex стойностите. Разликата е в мапинга на стойности:
	- От 0 до 9 мапваме 0 до 9
	- от 10 до 35 мапване a - z
	- от 36 до 62 мапваме A - Z
- Пример би било с Ид-то 11157
	1. 11157 % 62 = 59, намираме 59 в мапа и го преобразуваме в Х. Следващата операция ще е с резултата от 11157 / 62 = 179.
	2. 179 % 62 = 55, 55 мапваме към Т. Следваща операция 179 / 62 = 2.
	3. 2 % 62 = 2, 2 мапваме към 2. Следваща операция няма понеже 2 / 62 = 0.
Избираме да продължим с преобразуването в база 62, заради семплостта на подхода. Няма нужда да се справяме с колизии, защото всички ИД-та биха били уникални, нямаме от нужда от рекурсивни похвати. За сметка на това ни трябва генератор на глобално уникални ИД-та. Може би не споменах, че тези дълги и къси линкове ще се държат в релационна база данни, поради простият факт, че няма как да държим такъв обем данни в памет.

Как изглежда flow-a на системата? Първо нека обсъдим записващите операции.
1. Потребителя праща заявка за скъсяване на дълъг урл.
2. Load Balancer препраща заявката към web server.
3. Web Server-a проверява дали такъв дълъг УРЛ, съществува.
	1. Ако същестува връща вече създаденият къс УРЛ
	2. Ако не съществува
		1. Генерира ново ИД
		2. ИД-то се хешира
		3. Записва се ИД-то, дългият и късият УРЛ
Нека обсъдим препращащите заявки
1. Потребителя праща заявка с къс УРЛ.
2. Load Balancer препраща заявката към web server.
3. Проверяваме дали късият УРЛ е кеширан, ако е връщаме оригиналният урл.
4. В случай, че нямаме кеширана стойност, проверяваме базата с късият урл, ако съществува, преценяваме дали ще го кешираме и връщаме дългият УРЛ.
	1. Под връщаме имам предвим редиректваме. Имаме две стратегии за редирект. Постоянен и временен.
		1. 301 е постоянният редирект, при такива редиректи браузърът кешира редирект УРЛ-а и при следващи заявки към късият урл, той директно редиректва към оригиналният. Това е полезно за намаляване на натоварването към сървъра.
		2. 302 е временен, тоест при следващи заявки, потрбителят отново трябва да мине през редирект услугата ни. Полезно за събиране на аналитикс.
5. В случай, че не съществува в базата, уведомяваме потребителя.

В wrap-up-a можем да говорим за скалирана не сървъра и базата данни, за рейт лимитинг на заявките, как и защо да събираме аналитики и как да осигурим максимално разположение и консистентност на услугата.