Така общо взето тази глава е high level overview на една цялостна архитектура на една апликация. Като започваме с един семпъл сървър, който прави всичко с него комуникират клиенти (уеб и мобилна апликация), за комуникацията се използва dns (domain name system), който служи като указател мапват се рапознаваеми домейни, които лесно се разбират от човека към ИП-та.

Следваща стъпка е да се раздели сървъра на web tier и data tier, тоест да се издърпа базата данни в отделен сървър, като комуникацията от рекуест до респонс става client -> api -> db -> api -> client горе долу. Тук се споменават и различните видове бази данни - релационни SQL (MySql, PostegreSQL, MariaDB (май) и т.н.) и нерелационни -  NoSQL като тук вече има няколко подвида, най-известните са key value (Redis, Casandra) и document (Mongo). По-принцип трябва да се избере правилната база данни според зависи от use case-а, с релационните бази предпочитаме да работим, когато са ни нормализирани данните, а с nosql базите, когато работим с json-и, големи обеми неструктурирана дата и т.н.

Така после скейлваме сървъра, можем да го скейлнем вертикално (повече "желязо", тоест добавяме рам, или cpu power, или други хардуерни модификации), по-принцип това е по-лесният начин, но е и по-лимитиран, ако дропне единственият ни сървър сме до там, също така не можем да добавяме "желязо" завинаги. Вторият вариант е хоризонтален скейлинг, тоест правим няколко инстанции на нашият сървър, които да работят едновременно. За да работят тези сървъри едновременно и ефикасно използваме load balancer, като reverse proxy, тоест имаме един публичен адрес, към който се пращат рекуести и от там се разпределят по сървърите като комуникацията между проксито и сървърите се случва чрез прайвът ип адресите на самите сървъри. Има различни начини да се разпределят рекуестите, чел съм преди, но не помня как точно става, само помня термина round robin.

Така към този момент сме скейлнали хоризонтално и имаме няколко сървъра, тоест нямаме очевиден single point of failure, освен базата. Трябва да направим копия на базата или да я "репликираме", като този проблем е сравнително известен и често се имплментира master/slave концепцията, където имаме една мастър база, която да хандлева записванията или мутиращите операции и слейв бази, които да се занимават с четенето на данни, като най-често имаме повече slave от колктоо master бази, понеже се очаква, че ще четем повече от колкото ще записваме, но това зависи от апликацията. В случай, че мастъра фейлне, промоутваме слейв, в случай, че всички слийв фейлнат използваме мастъра за всички операции, разбира се докато не установим и оправим проблема.

Можем да скейлнем също базата, начините пак са вертикално и хоризонално. Вертикалният начин е подобен, просто увеличаваме капацитета хардуерно и удряме същите проблеми. Хоризонталният начин е малко по-различен, понеже различните бази биха имали същата схема, но различни данни, в такъв случай за да работим с тях трябва да имплементираме хешираща система, подобно на имплементацията на хаш мапа, трябва да съобразим какъв ще е хеширащният ключ за да имаме равно разпределени и консистентн данни, също трябва да предвидим в случай на увеличение на броя бази как ще се рехешират данните.

След като сме готови с основните нещa по архитектурата трябва да подобрим performance-а, първото нещо, което можем да имплементираме е кеширане на скъпи за изчисление или компутиране операции и такива, които са често изпълнявани. Кеша би служил като посредник между апито и базата за точно определени операции, като апито би питало дали определен резултат е кеширан и ако е просто ще бъде врънат, ако не е ще се рекуестне към базата, ще се запише в кеша и ще се върне към сървъра. Проблеми с кеширането винаги има, трябва да се предвиди колко време ще остане един резултат кеширан, какво би станало ако кеша фейлне, ще се справят ли апито и базата, при мутация на данните в базата как ще се инвалидира кешираната стойност и т.н, "най-трудното в програмирането е именуването на променливи и инвалидацията на кеша".

Би било хубаво и да вкараме в употреба CDN, който да предлага статични ресурси (снимки, видео файлове и т.н.) бързо на потребителите. Тези системи са дистрибутирани на различни географски локации, като факта, че може да са географски по-близко до потребителите ги прави по-бързи и съответно прави нашата апликация по-приятна за използване. Тези CDN-и са услуги, които се предлагат от трети лица и трябва да внимаваме с това, колко и какви ресурси предлагаме за да сме сигурни, че стойността, която ще заплатим ще сътветсва на предимствата, същият проблем имам и с консистентността на данните, тоест за колко време те ще са валидни и как да ги инвалидираме тези ресурси.

Можем да се възползваме и от различни географски точки и със сървърите ни, като ги раположим в различни дата центрове. Съответно трябва да се справим с проблеми като раутинг на рекуести, поведението на сървърите на различни точки по света и т.н. Правейки това също се защитаваме от различни физически проблеми като бедствия и др.

Споменават се message queue-тата, които се използват за асинхронна комуникация между различни услуги като има някои, които публикуват съобщения или създават job-ове и други услуги, които са абонирани за кю-то и реагират на публикувани съобщения или изпълняват job-ове. Нито за пъба има значение дали съба е в операционно състояние, нито обратното. Могат да се създават отделни worker-и, които да изпълняват job-овете паралелно.

А, добра практика е да събираме логове от различни грешки, които са се случили, различни бизнес метрики като активни потребители и т.н. според зависи от нуждите.